```{r setup scales-chap, include = FALSE}
source("common.R")
columns(1, 2 / 3)
```

# (PART) Scales toolbox {-}

# Scales and guides {#scales}

Scales in ggplot2 control the mapping from data to aesthetics. They take your data and turn it into something that you can see, like size, colour, position or shape. They also provide the tools that let you interpret the plot: the axes and legends. You can generate many plots without knowing how scales work, but understanding scales and learning how to manipulate them will give you much more control.

\index{Scales}

Formally, each scale is a function from a region in data space (the domain of the scale) to a region in aesthetic space (the range of the scale). The axis or legend is the inverse function: it allows you to convert visual properties back to data. In ggplot2 these two roles are controlled by the same toolkit (the scale functions), but for expository reasons they are discussed separately in this book. In this chapter I will focus on the mapping from the data to the aesthetics, and in Chapter \@ref(guides) I will return to axes and legends. 

In Chapter \@ref(scales) I discussed the way a scale maps a variable to an aesthetic. This chapter is a natural continuation, discussing the role scales play in controlling the __guide__, the axis or legend associated with the scale. You might find it surprising that axes and legends are the same type of thing, but while they look very different they have the same purpose: to allow you to read observations from the plot and map them back to their original values. 

In ggplot2, guides are produced automatically based on the layers in your plot. You don't directly control the legends and axes; instead you set up the data so that there's a clear mapping between data and aesthetics, and a guide is generated for you. This is very different to base R graphics, where you have total control over the legend, and can be frustrating when you first start using ggplot2. However, once you get the hang of it, you'll find that it saves you time, and there is little you cannot do.

The early sections of this chapter highlight functionality that is shared by axes and legends. Section \@ref(scale-name) discusses the `name` argument, while Section \@ref(scale-breaks) covers `breaks` and Section \@ref(scale-labels) discusses `labels`. 

| Argument name   | Axis              | Legend        
|:----------------|:------------------|:--------------
| `name`          | Label             | Title         
| `breaks`        | Ticks & grid line | Key           
| `labels`        | Tick label        | Key label     

```{r guides, echo = FALSE, out.width = "100%", fig.cap = "Common components of axes and legends"}
knitr::include_graphics("diagrams/scale-guides.png", dpi = 300, auto_pdf = TRUE)
```

Later parts of the chapter focuses mostly on legends because they are more complicated than axes:

1.  A legend can display multiple aesthetics (e.g. colour and shape), from
    multiple layers, and the symbol displayed in a legend varies based on the
    geom used in the layer.
   
1.  Axes always appear in the same place. Legends can appear in different 
    places, so you need some global way of controlling them.
  
1.  Legends have considerably more details that can be tweaked: should they
    be displayed vertically or horizontally? How many columns? How big should
    the keys be?
    
Reflecting this additional complexity, Section \@ref(scale-guide) discusses guide functions, most of which relate to legends. Section \@ref(legend-merge-split) discusses how legends are split and merged across layers, Section \@ref(legend-layout) focuses on legend layout and positioning, while Section \@ref(legend-glyph) shows you how to modify the glyphs displayed in the legend key.


## Scale specification {#scale-usage}

An important property of ggplot2 is the principle that every aesthetic in your plot is associated with exactly one scale. For instance, when you write:

```{r default-scales, fig.show = "hide"}
ggplot(mpg, aes(displ, hwy)) + 
  geom_point(aes(colour = class))
```

ggplot2 added a default scale for each aesthetic used in the plot: 
```{r, fig.show = "hide"}
ggplot(mpg, aes(displ, hwy)) + 
  geom_point(aes(colour = class)) +
  scale_x_continuous() + 
  scale_y_continuous() + 
  scale_colour_discrete()
```

The choice of default scale depends on the aesthetic and the variable type. In this example `hwy` is a continuous variable mapped to the y aesthetic so the default scale is `scale_y_continuous()`; similarly `class` is discrete so when mapped to the colour aesthetic the default scale becomes `scale_colour_discrete()`. 

Specifying these defaults would be tedious so ggplot2 does it for you. But if you want to override the defaults, you'll need to add the scale yourself, like this: \index{Scales!defaults}

<!-- HW: probably need a different example since I think we'd now use labs() for this -->
<!-- DN: note to self: revisit this during the restructure -->

```{r, fig.show = "hide"}
ggplot(mpg, aes(displ, hwy)) + 
  geom_point(aes(colour = class)) + 
  scale_x_continuous("A really awesome x axis label") +
  scale_y_continuous("An amazingly great y axis label")
```

The use of `+` to "add" scales to a plot is a little misleading because if you supply two scales for the same aesthetic, the last scale takes precedence. In other words, when you `+` a scale, you're not actually adding it to the plot, but overriding the existing scale. This means that the following two specifications are equivalent: \indexc{+} 

```{r multiple-scales, fig.show = "hide"}
ggplot(mpg, aes(displ, hwy)) + 
  geom_point() + 
  scale_x_continuous("Label 1") +
  scale_x_continuous("Label 2")

ggplot(mpg, aes(displ, hwy)) + 
  geom_point() + 
  scale_x_continuous("Label 2")
```

Note the message when you add multiple scales for the same aesthetic, which makes it harder to accidentally overwrite an existing scale. If you see this in your own code, you should make sure that you're only adding one scale to each aesthetic.

If you're making small tweaks to the scales, you might continue to use the default scales, supplying a few extra arguments. If you want to make more radical changes you will override the default scales with alternatives: 

```{r, fig.show = "hide"}
ggplot(mpg, aes(displ, hwy)) + 
  geom_point(aes(colour = class)) +
  scale_x_sqrt() + 
  scale_colour_brewer()
```

Here `scale_x_sqrt()` changes the scale for the x axis scale, and `scale_colour_brewer()` does the same for the colour scale.

The scale functions intended for users all follow a common naming scheme. You've probably already figured out the scheme, but to be concrete, it's made up of three pieces separated by "_":

1. `scale`
1. The name of the primary aesthetic (e.g., `colour`, `shape` or `x`)
1. The name of the scale (e.g., `continuous`, `discrete`, `brewer`).

The naming structure is often helpful, but can sometimes be ambiguous. For example, it is immediately clear that `scale_x_*()` functions apply to the x aesthetic, but it takes a little more thought to recognise that they also govern the behaviour of other aesthetics that describe a horizontal position (e.g., the `xmin`, `xmax`, and `xend` aesthetics). Similarly, while the name `scale_colour_continuous()` clearly refers to the colour scale associated with a continuous variables, it is less obvious that `scale_colour_distiller()` is simply a different method for creating colour scales for continuous variables. In this chapter I will try to clarify this structure as much as possible: more generally, the help documentation for each scale function may be helpful.


### Exercises

1.  What happens if you pair a discrete variable with a continuous scale?
    What happens if you pair a continuous variable with a discrete scale?

1.  Simplify the following plot specifications to make them easier to 
    understand.
    
    ```{r, eval = FALSE}
    ggplot(mpg, aes(displ)) + 
      scale_y_continuous("Highway mpg") + 
      scale_x_continuous() +
      geom_point(aes(y = hwy))

    ggplot(mpg, aes(y = displ, x = class)) + 
      scale_y_continuous("Displacement (l)") + 
      scale_x_discrete("Car type") +
      scale_x_discrete("Type of car") + 
      scale_colour_discrete() + 
      geom_point(aes(colour = drv)) + 
      scale_colour_discrete("Drive\ntrain")
    ```

## Scale limits {#limits}
\index{Axis!limits} \index{Scales!limits}

<!--HW: I took a stab at this but it needs more work. I don't think domain vs range are natural to most people -->
<!-- DN: note to self: revisit this during the restructure -->

All scales have limits that define the domain over which the scale is defined and are usually derived from the range of the data. Here we'll discuss why you might want to specify the limits rather than relying on the data:

1. You want to shrink the limits to focus on an interesting area of the plot.
1. You want to expand the limits to make multiple plots match up.

It's most natural to think about the limits of position scales: they map directly to the ranges of the axes. But limits also apply to scales that have legends, like colour, size, and shape, and these limits are particularly important if you want colours to be consistent across multiple plots. 

Use the `limits` argument to modify limits:

* For continuous scales, `limits` should be a numeric vector of length two. 
  If you only want to set the upper or lower limit, you can set the other value
  to `NA`.
  
* For discrete scales, `limits` should a character vector that enumerates all 
  possible values.

A minimal example is shown below. In the left panel the limits of the x scale are set to the default values (the range of the data), the middle panel expands the limits, and the right panel shrinks them:

`r columns(3)`
```{r, messages = FALSE}
df <- data.frame(x = 1:3, y = 1:3)
base <- ggplot(df, aes(x, y)) + geom_point() 

base
base + scale_x_continuous(limits = c(0, 4))
base + scale_x_continuous(limits = c(1.5, 2.5))
```


You might be surprised that the final plot generates a warning, as there's no missing value in the input dataset. I'll talk about this in Section \@ref(oob). 

### Setting multiple limits

Manually setting scale limits is a common task when you need to ensure that scales in different plots are consistent with one another. When you create a faceted plot, ggplot2 automatically does this for you:

`r columns(1, aspect_ratio = 1/2, max_width = 1)`
```{r}
ggplot(mpg, aes(displ, hwy, colour = fl)) + 
  geom_point() +
  facet_wrap(vars(year))
```

(Colour represents the fuel type, which can be **r**egular, **e**thanol, **d**iesel, **p**remium or *c*ompressed natural gas)

In this plot the x and y axes have the same limits in both facets and the colours are consistent. However, it is sometimes necessary to maintain consistency across multiple plots, which has the often-undesirable property of causing each plot to set scale limits independently:

`r columns(2, 1)`
```{r}
mpg_99 <- mpg %>% filter(year == 1999)
mpg_08 <- mpg %>% filter(year == 2008)

base_99 <- ggplot(mpg_99, aes(displ, hwy, colour = fl)) + geom_point() 
base_08 <- ggplot(mpg_08, aes(displ, hwy, colour = fl)) + geom_point() 

base_99
base_08
```

Each plot makes sense on its own, but visual comparison between the two is difficult. The axis limits are different, and because only regular, premium and diesel fuels are represented in the 1998 data the colours are mapped inconsistently. 

Because modifying scale limits is such a common task, ggplot2 provides some convenience functions to make this easier. For position scales the `xlim()` and `ylim()` helper functions inspect their input and then specify the appropriate scale for the x and y axes respectively. More generally, the `lims()` function takes name-value pairs as input, where the name specifies the aesthetic and the value specifies the limits. The results depend on the type of scale: \indexf{xlim}  \indexf{ylim}

* `xlim(10, 20)`: a continuous scale from 10 to 20
* `ylim(20, 10)`: a reversed continuous scale from 20 to 10
* `xlim("a", "b", "c")`: a discrete scale
* `xlim(as.Date(c("2008-05-01", "2008-08-01")))`: a date scale from May 1 to August 1 2008 (date scales are discussed in Section \@ref(date-scales))

To ensure consistent axis scaling in the previous example, we can use these helper functions:

```{r}
base_99 + xlim(1, 7) + ylim(10, 45)
base_08 + xlim(1, 7) + ylim(10, 45)
```

In many cases the `xlim()` and `ylim()` functions would be sufficient to solve the problem, but in this example we still need to ensure that the colour scale is consistent across plots. The `lims()` function is particularly useful for this purpose, as it allows the user to set the scale limits for any aesthetic:

```{r}
base_99 + lims(x = c(1, 7), y = c(10, 45), colour = c("c", "d", "e", "p", "r"))
base_08 + lims(x = c(1, 7), y = c(10, 45), colour = c("c", "d", "e", "p", "r"))
```

Note that because the fuel variable `fl` is discrete, the limits for the colour aesthetic are a vector of possible values rather than the two end points.


### Out of bounds values {#oob}
\index{Zooming}

By default, ggplot2 converts data outside the scale limits to `NA`. This means that changing the limits of a scale is not precisely the same as visually zooming in to a region of the plot. If your goal is to zoom in part of the plot, it is better to use the `xlim` and `ylim` arguments to `coord_cartesian()`:

`r columns(3, 1.5)`
```{r}
base <- ggplot(mpg, aes(drv, hwy)) + 
  geom_hline(yintercept = 28, colour = "red") + 
  geom_boxplot() 

base
base + coord_cartesian(ylim = c(10, 35)) # zoom only
base + ylim(10, 35) # alters the boxplot
```

The only difference between the left and middle plots is that that the latter is zoomed in. Some of the outlier points are not shown due to the restriction of range, but the boxplots themselves remain identical. In contrast, in the plot on the right one of the boxplots has changed. When `ylim()` is used to set the scale limits, all observations with highway mileage greater than 35 are converted to `NA` before the stat (in this case the boxplot) is computed. This has the effect of shifting the sample median downward. You can learn more about coordinate systems in Section \@ref(cartesian).

Although the default behaviour in to convert the **o**ut **o**f **b**ounds values to `NA`, you can override this by setting `oob` argument to the scale, a function that is applied to all observations outside the scale limits. The default `scales::censor()` which replaces any value outside the limits with `NA`. Another option is `scales::squish()` which squishes all values into the range. An example using a fill scale is shown below:

`r columns(3,1)`
```{r}
df <- data.frame(x = 1:6, y = 8:13)
base <- ggplot(df, aes(x, y)) + 
  geom_col(aes(fill = x)) +                    # bar chart
  geom_vline(xintercept = 3.5, colour = "red") # for visual clarity only

base
base + scale_fill_gradient(limits = c(1, 3))
base + scale_fill_gradient(limits = c(1, 3), oob = scales::squish)
```

On the left the default fill colours are shown, ranging from dark blue to light blue. In the middle panel the scale limits for the fill aesthetic are reduced so that the values for the three rightmost bars are replace with `NA` and are mapped to a grey shade. In some cases this is desired behaviour but often it is not: the right panel addresses this by modifying the `oob` function appropriately.  


## Scale names {#scale-name}

A common task when creating plots is to customise the title of the axes and legends. To illustrate how this is done, I'll create a small  `toy` data frame that I will reuse throughout the chapter:
    
```{r}
toy <- data.frame(
  const = 1, 
  up = 1:4,
  txt = letters[1:4], 
  big = (1:4)*1000,
  log = c(2, 5, 10, 2000)
)
toy
```

The axis or legend title is specified by `name`, which is always the first argument to the scale function. Usually this argument takes a text string as input, using `\n` to specify line breaks, but you can supply mathematical expressions wrapped `quote()`, as described in `?plotmath`
\index{Axis!title} \index{Legend!title}
    
`r columns(2, 1 / 2)`
```{r guide-names}
base <- ggplot(toy, aes(up, up)) + geom_point()

base + scale_x_continuous("X axis")
base + scale_x_continuous(quote(a + mathematical ^ expression))
```

It is also possible to include (some) markdown in axis and legend titles with the help of the ggtext package [@ggtext] and the ggplot2 theme system (see Chapter \@ref(polishing)). To enable markdown you need to set the relevant theme element to `ggtext::element_markdown()`, as demonstrated below:

`r columns(2, 1 / 2)`
```{r markdown-with-ggtext}
base <- ggplot(toy, aes(up, up)) + 
  geom_point() + 
  scale_x_continuous("Axis title with *italics* and **boldface**")

base
base + theme(axis.title.x = ggtext::element_markdown())
```

Because tweaking axis and legend labels is such a common task, ggplot2 provides the `labs()` helper function that saves you some typing. It allows you to set the name for one or more scales, using name-value pairs like `x = "X axis"` or `fill = "fill legend"`. It also allows you to specify other plot labels, like titles, subtitles, captions and tags (see Section \@ref(titles)):

`r columns(2, 2/3)`
```{r guide-names-helper}
ggplot(toy, aes(const, up)) + 
  geom_point(aes(colour = txt)) + 
  labs(
    x = "X axis", 
    y = quote(Y^axis), 
    colour = "Colour\nlegend",
    title = "A pithy title",
    subtitle = "A more precise subtitle"
  )
```

There are two ways to remove the axis label. Setting `labs(x = "")` omits the label but still allocates space; setting `labs(x = NULL)` removes the label and its space. 


## Legend positioning {#legend-layout}

A number of settings that affect the overall display of the legends are controlled through the theme system. You'll learn more about that in Section \@ref(themes), but for now, all you need to know is that you modify theme settings with the `theme()` function. \index{Themes!legend} 

The position and justification of legends are controlled by the theme setting `legend.position`, which takes values "right", "left", "top", "bottom", or "none" (no legend). \index{Legend!layout}

`r columns(2, 2/3)`
```{r legend-position}
base <- ggplot(toy, aes(up, up)) + 
  geom_point(aes(colour = txt), size = 3) + 
  xlab(NULL) + 
  ylab(NULL)

base + theme(legend.position = "left")
base + theme(legend.position = "right") # the default 
base + theme(legend.position = "bottom")
base + theme(legend.position = "none")
```

Switching between left/right and top/bottom modifies how the keys in each legend are laid out (horizontal or vertically), and how multiple legends are stacked (horizontal or vertically). If needed, you can adjust those options independently:

* `legend.direction`: layout of items in legends ("horizontal" or "vertical").

* `legend.box`: arrangement of multiple legends ("horizontal" or "vertical").

* `legend.box.just`: justification of each legend within the overall bounding 
   box, when there are multiple legends ("top", "bottom", "left", or "right").

Alternatively, if there's a lot of blank space in your plot you might want to place the legend inside the plot. You can do this by setting `legend.position` to a numeric vector of length two. The numbers represent a relative location in the panel area: `c(0, 1)` is the top-left corner and `c(1, 0)` is the bottom-right corner. You control which corner of the legend the `legend.position` refers to with `legend.justification`, which is specified in a similar way. Unfortunately positioning the legend exactly where you want it requires a lot of trial and error.

`r columns(3, 1.5)`
```{r legend-position-man}
base <- ggplot(toy, aes(up, up)) + 
  geom_point(aes(colour = txt), size = 3)

base + theme(legend.position = c(0, 1), legend.justification = c(0, 1))
base + theme(legend.position = c(0.5, 0.5), legend.justification = c(0.5, 0.5))
base + theme(legend.position = c(1, 0), legend.justification = c(1, 0))
```

There's also a margin around the legends, which you can suppress with `legend.margin = unit(0, "mm")`.



## Legend merging and splitting {#legend-merge-split}

There is always a one-to-one correspondence between position scales and axes. But the connection between non-position scales and legend is more complex: one legend may need to draw symbols from multiple layers ("merging"), or one aesthetic may need multiple legends ("splitting").

### Merging legends {#sub-layers-legends}
\index{Legend}

Merging legends occurs quite frequently when using ggplot2. For example, if you've mapped colour to both points and lines, the keys will show both points and lines. If you've mapped fill colour, you get a rectangle. Note the way the legend varies in the plots below:

`r columns(3)`
```{r legend-geom, echo = FALSE}
base <- ggplot(toy, aes(const, up, colour = txt))
base + geom_point()
base + geom_point() + geom_path(aes(group = 1))
base + geom_raster(aes(fill = txt))
```

By default, a layer will only appear if the corresponding aesthetic is mapped to a variable with `aes()`. You can override whether or not a layer appears in the legend with `show.legend`: `FALSE` to prevent a layer from ever appearing in the legend; `TRUE` forces it to appear when it otherwise wouldn't. Using `TRUE` can be useful in conjunction with the following trick to make points stand out:

`r columns(2, 2/3)`
```{r}
ggplot(toy, aes(up, up)) + 
  geom_point(size = 4, colour = "grey20") +
  geom_point(aes(colour = txt), size = 2) 

ggplot(toy, aes(up, up)) + 
  geom_point(size = 4, colour = "grey20", show.legend = TRUE) +
  geom_point(aes(colour = txt), size = 2) 
```

ggplot2 tries to use the fewest number of legends to accurately convey the aesthetics used in the plot. It does this by combining legends where the same variable is mapped to different aesthetics. The figure below shows how this works for points: if both colour and shape are mapped to the same variable, then only a single legend is necessary. \index{Legend!merging}

`r columns(3)`
```{r legend-merge}
base <- ggplot(toy, aes(const, up)) +
  scale_x_continuous(NULL, breaks = NULL)
base + geom_point(aes(colour = txt))
base + geom_point(aes(shape = txt))
base + geom_point(aes(shape = txt, colour = txt))
```

In order for legends to be merged, they must have the same `name`. So if you change the name of one of the scales, you'll need to change it for all of them. One way to do this is by using `labs()` helper function:

`r columns(3, 3/2)`
```{r}
base <- ggplot(toy, aes(const, up)) + 
  geom_point(aes(shape = txt, colour = txt)) + 
  scale_x_continuous(NULL, breaks = NULL)

base
base + labs(shape = "Split legend")
base + labs(shape = "Merged legend", colour = "Merged legend")
```


### Splitting legends

Splitting a legend is a much less common data visualisation task. In general it is not advisable to map one aesthetic (e.g. colour) to multiple variables, and so by default ggplot2 does not allow you to "split" the colour aesthetic into multiple scales with separate legends. Nevertheless, there are exceptions to this general rule, and it is possible to override this behaviour using the ggnewscale package [@ggnewscale]. The `ggnewscale::new_scale_colour()` command acts as an instruction to ggplot2 to initialise a new colour scale: scale and guide commands that appear above the `new_scale_colour()` command will be applied to the first colour scale, and commands that appear below are applied to the second colour scale. 

To illustrate this the plot on the left uses `geom_point()` to display a large marker for each vehicle make in the `mpg` data, with a single colour scale that maps to the year. On the right, a second `geom_point()` layer is overlaid on the plot using small markers: this layer is associated with a different colour scale, used to indicate whether the vehicle has a 4-cylinder engine.

`r columns(2, 2/3)`
```{r}
base <- ggplot(mpg, aes(displ, hwy)) + 
  geom_point(aes(colour = factor(year)), size = 5) + 
  scale_colour_brewer("year", type = "qual", palette = 5) 

base
base + 
  ggnewscale::new_scale_colour() + 
  geom_point(aes(colour = cyl == 4), size = 1, fill = NA) + 
  scale_colour_manual("4 cylinder", values = c("grey60", "black"))
```

Additional details, including functions that apply to other scale types, are available on the package website, <https://github.com/eliocamp/ggnewscale>.


## Legend key glyphs {#legend-glyph}

In most cases the default glyphs shown in the legend key will be appropriate to the layer and the aesthetic. Line plots of different colours will show up as lines of different colours in the legend, boxplots will appear as small boxplots in the legend, and so on. Should you need to override this behaviour, the `key_glyph` argument can be used to associate a particular layer with a different kind of glyph. For example:

`r columns(2, 1/2)`
```{r}
base <- ggplot(economics, aes(date, psavert, color = "savings"))

base + geom_line()
base + geom_line(key_glyph = "timeseries")
```

More precisely, each geom is associated with a function such as `draw_key_path()`, `draw_key_boxplot()` or `draw_key_path()` which is responsible for drawing the key when the legend is created. You can pass the desired key drawing function directly: for example, `base + geom_line(key_glyph = draw_key_timeseries)` would also produce the plot shown above right.



### Exercises

1.  How do you make legends appear to the left of the plot?

1.  What's gone wrong with this plot? How could you fix it?

    `r columns(1, 2 / 3)`
    ```{r}
    ggplot(mpg, aes(displ, hwy)) + 
      geom_point(aes(colour = drv, shape = drv)) + 
      scale_colour_discrete("Drive train")
    ```

1.  Can you recreate the code for this plot?

    `r columns(1, 2 / 3)`
    ```{r, echo = FALSE}
    ggplot(mpg, aes(displ, hwy, colour = class)) + 
      geom_point(show.legend = FALSE) + 
      geom_smooth(method = "lm", se = FALSE) + 
      theme(legend.position = "bottom") + 
      guides(colour = guide_legend(nrow = 1))
    ```






