```{r setup scales-chap, include = FALSE}
source("common.R")
columns(1, 2 / 3)
```

# (PART) Scales Toolbox {-}

# Scales {#scales}

Scales in ggplot2 control the mapping from data to aesthetics. They take your data and turn it into something that you can see, like size, colour, position or shape. They also provide the tools that let you interpret the plot: the axes and legends. You can generate many plots without knowing how scales work, but understanding scales and learning how to manipulate them will give you much more control.

\index{Scales}

Formally, each scale is a function from a region in data space (the domain of the scale) to a region in aesthetic space (the range of the scale). The axis or legend is the inverse function: it allows you to convert visual properties back to data. In ggplot2 these two roles are controlled by the same toolkit (the scale functions), but for expository reasons they are discussed separately in this book. In this chapter I will focus on the mapping from the data to the aesthetics, and in Chapter \@ref(guides) I will return to axes and legends. 

In Chapter \@ref(scales) I discussed the way a scale maps a variable to an aesthetic. This chapter is a natural continuation, discussing the role scales play in controlling the __guide__, the axis or legend associated with the scale. You might find it surprising that axes and legends are the same type of thing, but while they look very different they have the same purpose: to allow you to read observations from the plot and map them back to their original values. 

In ggplot2, guides are produced automatically based on the layers in your plot. You don't directly control the legends and axes; instead you set up the data so that there's a clear mapping between data and aesthetics, and a guide is generated for you. This is very different to base R graphics, where you have total control over the legend, and can be frustrating when you first start using ggplot2. However, once you get the hang of it, you'll find that it saves you time, and there is little you cannot do.

The early sections of this chapter highlight functionality that is shared by axes and legends. Section \@ref(scale-name) discusses the `name` argument, while Section \@ref(scale-breaks) covers `breaks` and Section \@ref(scale-labels) discusses `labels`. 

| Argument name   | Axis              | Legend        
|:----------------|:------------------|:--------------
| `name`          | Label             | Title         
| `breaks`        | Ticks & grid line | Key           
| `labels`        | Tick label        | Key label     

```{r guides, echo = FALSE, out.width = "100%", fig.cap = "Common components of axes and legends"}
knitr::include_graphics("diagrams/scale-guides.png", dpi = 300, auto_pdf = TRUE)
```

Later parts of the chapter focuses mostly on legends because they are more complicated than axes:

1.  A legend can display multiple aesthetics (e.g. colour and shape), from
    multiple layers, and the symbol displayed in a legend varies based on the
    geom used in the layer.
   
1.  Axes always appear in the same place. Legends can appear in different 
    places, so you need some global way of controlling them.
  
1.  Legends have considerably more details that can be tweaked: should they
    be displayed vertically or horizontally? How many columns? How big should
    the keys be?
    
Reflecting this additional complexity, Section \@ref(scale-guide) discusses guide functions, most of which relate to legends. Section \@ref(legend-merge-split) discusses how legends are split and merged across layers, Section \@ref(legend-layout) focuses on legend layout and positioning, while Section \@ref(legend-glyph) shows you how to modify the glyphs displayed in the legend key.


## Scale specification {#scale-usage}

An important property of ggplot2 is the principle that every aesthetic in your plot is associated with exactly one scale. For instance, when you write:

```{r default-scales, fig.show = "hide"}
ggplot(mpg, aes(displ, hwy)) + 
  geom_point(aes(colour = class))
```

ggplot2 added a default scale for each aesthetic used in the plot: 
```{r, fig.show = "hide"}
ggplot(mpg, aes(displ, hwy)) + 
  geom_point(aes(colour = class)) +
  scale_x_continuous() + 
  scale_y_continuous() + 
  scale_colour_discrete()
```

The choice of default scale depends on the aesthetic and the variable type. In this example `hwy` is a continuous variable mapped to the y aesthetic so the default scale is `scale_y_continuous()`; similarly `class` is discrete so when mapped to the colour aesthetic the default scale becomes `scale_colour_discrete()`. 

Specifying these defaults would be tedious so ggplot2 does it for you. But if you want to override the defaults, you'll need to add the scale yourself, like this: \index{Scales!defaults}

<!-- HW: probably need a different example since I think we'd now use labs() for this -->
<!-- DN: note to self: revisit this during the restructure -->

```{r, fig.show = "hide"}
ggplot(mpg, aes(displ, hwy)) + 
  geom_point(aes(colour = class)) + 
  scale_x_continuous("A really awesome x axis label") +
  scale_y_continuous("An amazingly great y axis label")
```

The use of `+` to "add" scales to a plot is a little misleading because if you supply two scales for the same aesthetic, the last scale takes precedence. In other words, when you `+` a scale, you're not actually adding it to the plot, but overriding the existing scale. This means that the following two specifications are equivalent: \indexc{+} 

```{r multiple-scales, fig.show = "hide"}
ggplot(mpg, aes(displ, hwy)) + 
  geom_point() + 
  scale_x_continuous("Label 1") +
  scale_x_continuous("Label 2")

ggplot(mpg, aes(displ, hwy)) + 
  geom_point() + 
  scale_x_continuous("Label 2")
```

Note the message when you add multiple scales for the same aesthetic, which makes it harder to accidentally overwrite an existing scale. If you see this in your own code, you should make sure that you're only adding one scale to each aesthetic.

If you're making small tweaks to the scales, you might continue to use the default scales, supplying a few extra arguments. If you want to make more radical changes you will override the default scales with alternatives: 

```{r, fig.show = "hide"}
ggplot(mpg, aes(displ, hwy)) + 
  geom_point(aes(colour = class)) +
  scale_x_sqrt() + 
  scale_colour_brewer()
```

Here `scale_x_sqrt()` changes the scale for the x axis scale, and `scale_colour_brewer()` does the same for the colour scale.

The scale functions intended for users all follow a common naming scheme. You've probably already figured out the scheme, but to be concrete, it's made up of three pieces separated by "_":

1. `scale`
1. The name of the primary aesthetic (e.g., `colour`, `shape` or `x`)
1. The name of the scale (e.g., `continuous`, `discrete`, `brewer`).

The naming structure is often helpful, but can sometimes be ambiguous. For example, it is immediately clear that `scale_x_*()` functions apply to the x aesthetic, but it takes a little more thought to recognise that they also govern the behaviour of other aesthetics that describe a horizontal position (e.g., the `xmin`, `xmax`, and `xend` aesthetics). Similarly, while the name `scale_colour_continuous()` clearly refers to the colour scale associated with a continuous variables, it is less obvious that `scale_colour_distiller()` is simply a different method for creating colour scales for continuous variables. In this chapter I will try to clarify this structure as much as possible: more generally, the help documentation for each scale function may be helpful.

Before diving into the details of how scale functions work, it is useful to note that internally all scale functions in ggplot2 belong to one of three fundamental types; continuous scales, discrete scales, and binned scales. Each fundamental type is handled by one of three scale constructor functions; `continuous_scale()`, `discrete_scale()` and `binned_scale()`. Although you should never need to call these constructor functions, they form the organising structure for later sections in this chapter.

### Exercises

1.  What happens if you pair a discrete variable with a continuous scale?
    What happens if you pair a continuous variable with a discrete scale?

1.  Simplify the following plot specifications to make them easier to 
    understand.
    
    ```{r, eval = FALSE}
    ggplot(mpg, aes(displ)) + 
      scale_y_continuous("Highway mpg") + 
      scale_x_continuous() +
      geom_point(aes(y = hwy))

    ggplot(mpg, aes(y = displ, x = class)) + 
      scale_y_continuous("Displacement (l)") + 
      scale_x_discrete("Car type") +
      scale_x_discrete("Type of car") + 
      scale_colour_discrete() + 
      geom_point(aes(colour = drv)) + 
      scale_colour_discrete("Drive\ntrain")
    ```

## Scale limits {#limits}
\index{Axis!limits} \index{Scales!limits}

<!--HW: I took a stab at this but it needs more work. I don't think domain vs range are natural to most people -->
<!-- DN: note to self: revisit this during the restructure -->

All scales have limits that define the domain over which the scale is defined and are usually derived from the range of the data. Here we'll discuss why you might want to specify the limits rather than relying on the data:

1. You want to shrink the limits to focus on an interesting area of the plot.
1. You want to expand the limits to make multiple plots match up.

It's most natural to think about the limits of position scales: they map directly to the ranges of the axes. But limits also apply to scales that have legends, like colour, size, and shape, and these limits are particularly important if you want colours to be consistent across multiple plots. 

Use the `limits` argument to modify limits:

* For continuous scales, `limits` should be a numeric vector of length two. 
  If you only want to set the upper or lower limit, you can set the other value
  to `NA`.
  
* For discrete scales, `limits` should a character vector that enumerates all 
  possible values.

A minimal example is shown below. In the left panel the limits of the x scale are set to the default values (the range of the data), the middle panel expands the limits, and the right panel shrinks them:

`r columns(3)`
```{r, messages = FALSE}
df <- data.frame(x = 1:3, y = 1:3)
base <- ggplot(df, aes(x, y)) + geom_point() 

base
base + scale_x_continuous(limits = c(0, 4))
base + scale_x_continuous(limits = c(1.5, 2.5))
```


You might be surprised that the final plot generates a warning, as there's no missing value in the input dataset. I'll talk about this in Section \@ref(oob). 

### Setting multiple limits

Manually setting scale limits is a common task when you need to ensure that scales in different plots are consistent with one another. When you create a faceted plot, ggplot2 automatically does this for you:

`r columns(1, aspect_ratio = 1/2, max_width = 1)`
```{r}
ggplot(mpg, aes(displ, hwy, colour = fl)) + 
  geom_point() +
  facet_wrap(vars(year))
```

(Colour represents the fuel type, which can be **r**egular, **e**thanol, **d**iesel, **p**remium or *c*ompressed natural gas)

In this plot the x and y axes have the same limits in both facets and the colours are consistent. However, it is sometimes necessary to maintain consistency across multiple plots, which has the often-undesirable property of causing each plot to set scale limits independently:

`r columns(2, 1)`
```{r}
mpg_99 <- mpg %>% filter(year == 1999)
mpg_08 <- mpg %>% filter(year == 2008)

base_99 <- ggplot(mpg_99, aes(displ, hwy, colour = fl)) + geom_point() 
base_08 <- ggplot(mpg_08, aes(displ, hwy, colour = fl)) + geom_point() 

base_99
base_08
```

Each plot makes sense on its own, but visual comparison between the two is difficult. The axis limits are different, and because only regular, premium and diesel fuels are represented in the 1998 data the colours are mapped inconsistently. 

Because modifying scale limits is such a common task, ggplot2 provides some convenience functions to make this easier. For position scales the `xlim()` and `ylim()` helper functions inspect their input and then specify the appropriate scale for the x and y axes respectively. More generally, the `lims()` function takes name-value pairs as input, where the name specifies the aesthetic and the value specifies the limits. The results depend on the type of scale: \indexf{xlim}  \indexf{ylim}

* `xlim(10, 20)`: a continuous scale from 10 to 20
* `ylim(20, 10)`: a reversed continuous scale from 20 to 10
* `xlim("a", "b", "c")`: a discrete scale
* `xlim(as.Date(c("2008-05-01", "2008-08-01")))`: a date scale from May 1 to August 1 2008 (date scales are discussed in Section \@ref(date-scales))

To ensure consistent axis scaling in the previous example, we can use these helper functions:

```{r}
base_99 + xlim(1, 7) + ylim(10, 45)
base_08 + xlim(1, 7) + ylim(10, 45)
```

In many cases the `xlim()` and `ylim()` functions would be sufficient to solve the problem, but in this example we still need to ensure that the colour scale is consistent across plots. The `lims()` function is particularly useful for this purpose, as it allows the user to set the scale limits for any aesthetic:

```{r}
base_99 + lims(x = c(1, 7), y = c(10, 45), colour = c("c", "d", "e", "p", "r"))
base_08 + lims(x = c(1, 7), y = c(10, 45), colour = c("c", "d", "e", "p", "r"))
```

Note that because the fuel variable `fl` is discrete, the limits for the colour aesthetic are a vector of possible values rather than the two end points.


### Out of bounds values {#oob}
\index{Zooming}

By default, ggplot2 converts data outside the scale limits to `NA`. This means that changing the limits of a scale is not precisely the same as visually zooming in to a region of the plot. If your goal is to zoom in part of the plot, it is better to use the `xlim` and `ylim` arguments to `coord_cartesian()`:

`r columns(3, 1.5)`
```{r}
base <- ggplot(mpg, aes(drv, hwy)) + 
  geom_hline(yintercept = 28, colour = "red") + 
  geom_boxplot() 

base
base + coord_cartesian(ylim = c(10, 35)) # zoom only
base + ylim(10, 35) # alters the boxplot
```

The only difference between the left and middle plots is that that the latter is zoomed in. Some of the outlier points are not shown due to the restriction of range, but the boxplots themselves remain identical. In contrast, in the plot on the right one of the boxplots has changed. When `ylim()` is used to set the scale limits, all observations with highway mileage greater than 35 are converted to `NA` before the stat (in this case the boxplot) is computed. This has the effect of shifting the sample median downward. You can learn more about coordinate systems in Section \@ref(cartesian).

Although the default behaviour in to convert the **o**ut **o**f **b**ounds values to `NA`, you can override this by setting `oob` argument to the scale, a function that is applied to all observations outside the scale limits. The default `scales::censor()` which replaces any value outside the limits with `NA`. Another option is `scales::squish()` which squishes all values into the range. An example using a fill scale is shown below:

`r columns(3,1)`
```{r}
df <- data.frame(x = 1:6, y = 8:13)
base <- ggplot(df, aes(x, y)) + 
  geom_col(aes(fill = x)) +                    # bar chart
  geom_vline(xintercept = 3.5, colour = "red") # for visual clarity only

base
base + scale_fill_gradient(limits = c(1, 3))
base + scale_fill_gradient(limits = c(1, 3), oob = scales::squish)
```

On the left the default fill colours are shown, ranging from dark blue to light blue. In the middle panel the scale limits for the fill aesthetic are reduced so that the values for the three rightmost bars are replace with `NA` and are mapped to a grey shade. In some cases this is desired behaviour but often it is not: the right panel addresses this by modifying the `oob` function appropriately.  


### Visual range expansion

If you have eagle eyes, you'll have noticed that the visual range of the axes actually extends a little bit past the numeric limits that I have specified in the various examples. This ensures that the data does not overlap the axes, which is usually (but not always) desirable. 

You can eliminate this this space with `expand = c(0, 0)`. One scenario where it is usually preferable to remove this space is when using `geom_raster()`: \index{Axis!expansion}

<!-- mention expansion() since it documents the parameters? -->

`r columns(2, 1, 1)`
```{r}
ggplot(faithfuld, aes(waiting, eruptions)) + 
  geom_raster(aes(fill = density)) + 
  theme(legend.position = "none")

ggplot(faithfuld, aes(waiting, eruptions)) + 
  geom_raster(aes(fill = density)) + 
  scale_x_continuous(expand = c(0,0)) + 
  scale_y_continuous(expand = c(0,0)) +
  theme(legend.position = "none")
```

### Exercises

1.  The following code creates two plots of the mpg dataset. Modify the code
    so that the legend and axes match, without using facetting!
    
    `r columns(2, 2/3)`
    ```{r}
    fwd <- subset(mpg, drv == "f")
    rwd <- subset(mpg, drv == "r")
    
    ggplot(fwd, aes(displ, hwy, colour = class)) + geom_point()
    ggplot(rwd, aes(displ, hwy, colour = class)) + geom_point()
    ```

1.  What does `expand_limits()` do and how does it work?  Read the source code.

1.  What happens if you add two `xlim()` calls to the same plot? Why?

1.  What does `scale_x_continuous(limits = c(NA, NA))` do?







<!-- DN: This was the beginning of the binned transformation section:

### Binned scales

`r columns(2)`
```{r}
base <- ggplot(mpg, aes(hwy)) + geom_bar()

p1 <- base + scale_x_binned(breaks = seq(-50,50,10), limits = c(-50, 50))
p2 <- base + scale_x_binned(breaks = seq(-50,50,10), limits = c(-50, 50), trans = "reverse")
```





Binned scales can be transformed, much like continuous scales, but some care is required because the bins are constructed in the transformed space. In some cases this can produce undesirable outcomes. In the code below, I take a uniformly distributed variable and use `scale_x_binned()` and `geom_bar()` to construct a histogram of the logarithmically transformed data. 

`r columns(1, 1/2, 1)`
```{r}
df <- data.frame(val = runif(10000, 1, 20000))
ggplot(df, aes(log10(val))) + geom_bar() + scale_x_binned()
```

In this example the transformation takes place in the data: the x aesthetic is mapped to the value of `log10(val)`, and no scale transformation is applied. The bins are evenly spaced on this logarithmic scale. Alternatively, you can specify the transformation by setting `trans = "log10"` in the scale function:

`r columns(1, 1/2, 1)`
```{r}
ggplot(df, aes(val)) + geom_bar() + scale_x_binned(trans="log10") 
```

The unevenly spaced bins occur due to an interaction of two things: (1) binned scales use breaks to construct the bins, and (2) the default breaks for a transformed scale are specified by the transformation and are designed to look nice, but may not be good for binning data. The solution to this is to override the default breaks: 

`r columns(1, 1/2, 1)`
```{r}
ggplot(df, aes(val)) + geom_bar() + 
  scale_x_binned(trans="log10", breaks = 3^(0:9))  
```

-->




## Scale names {#scale-name}

A common task when creating plots is to customise the title of the axes and legends. To illustrate how this is done, I'll create a small  `toy` data frame that I will reuse throughout the chapter:
    
```{r}
toy <- data.frame(
  const = 1, 
  up = 1:4,
  txt = letters[1:4], 
  big = (1:4)*1000,
  log = c(2, 5, 10, 2000)
)
toy
```

The axis or legend title is specified by `name`, which is always the first argument to the scale function. Usually this argument takes a text string as input, using `\n` to specify line breaks, but you can supply mathematical expressions wrapped `quote()`, as described in `?plotmath`
\index{Axis!title} \index{Legend!title}
    
`r columns(2, 1 / 2)`
```{r guide-names}
base <- ggplot(toy, aes(up, up)) + geom_point()

base + scale_x_continuous("X axis")
base + scale_x_continuous(quote(a + mathematical ^ expression))
```

It is also possible to include (some) markdown in axis and legend titles with the help of the ggtext package [@ggtext] and the ggplot2 theme system (see Chapter \@ref(polishing)). To enable markdown you need to set the relevant theme element to `ggtext::element_markdown()`, as demonstrated below:

`r columns(2, 1 / 2)`
```{r markdown-with-ggtext}
base <- ggplot(toy, aes(up, up)) + 
  geom_point() + 
  scale_x_continuous("Axis title with *italics* and **boldface**")

base
base + theme(axis.title.x = ggtext::element_markdown())
```

Because tweaking axis and legend labels is such a common task, ggplot2 provides the `labs()` helper function that saves you some typing. It allows you to set the name for one or more scales, using name-value pairs like `x = "X axis"` or `fill = "fill legend"`. It also allows you to specify other plot labels, like titles, subtitles, captions and tags (see Section \@ref(titles)):

`r columns(2, 2/3)`
```{r guide-names-helper}
ggplot(toy, aes(const, up)) + 
  geom_point(aes(colour = txt)) + 
  labs(
    x = "X axis", 
    y = quote(Y^axis), 
    colour = "Colour\nlegend",
    title = "A pithy title",
    subtitle = "A more precise subtitle"
  )
```

There are two ways to remove the axis label. Setting `labs(x = "")` omits the label but still allocates space; setting `labs(x = NULL)` removes the label and its space. 

## Scale breaks {#scale-breaks}

In the same way that the `name` argument to a scale function governs axis titles and legend titles, the `breaks` argument controls which values appear as tick marks on axes and as keys on legends. 
\index{Axis!ticks} \index{Axis!breaks}

`r columns(2, 2 / 3)`
```{r breaks-labels}
axs <- ggplot(toy, aes(big, const)) + 
  geom_point() + 
  labs(x = NULL, y = NULL)

axs
axs + scale_x_continuous(breaks = c(2000, 4000))
```

The examples below illustrate the same ideas applied to legends:

```{r}
leg <- ggplot(toy, aes(up, up, fill = big)) + 
  geom_tile() + 
  labs(x = NULL, y = NULL) 

leg 
leg + scale_fill_continuous(breaks = c(2000, 4000))
```

### Break functions {#break-functions}

In the examples above, I specified breaks manually, but ggplot2 also allows you to pass a function to `breaks`. This function should have one argument that specifies the limits of the scale (a numeric vector of length two), and it should return a numeric vector of breaks. You can write your own break function, but in many cases there is no need, thanks to the scales package [@scales]. It provides several tools that are useful for this purpose:

* `scales::breaks_extended()`	creates automatic breaks for numeric axes.
* `scales::breaks_log()`	creates breaks appropriate for log axes.
* `scales::breaks_pretty()`	creates "pretty" breaks for date/times.
* `scales::breaks_width()`	creates equally spaced breaks.

The `breaks_extended()` function is the standard method used in ggplot2, and accordingly the first two plots below are the same. I can alter the desired number of breaks by setting `n = 2`, as illustrated in the third plot. Note that `breaks_extended()` treats `n` as a suggestion rather than a strict constraint. If you need to specify exact breaks it is better to do so manually.  

`r columns(3, 1/2)`
```{r}
axs
axs + scale_x_continuous(breaks = scales::breaks_extended())
axs + scale_x_continuous(breaks = scales::breaks_extended(n = 2))
```

Another approach that is sometimes useful is specifying a fixed `width` that defines the spacing between breaks. The `breaks_width()` function is used for this. The first example below shows how to fix the width at a specific value; the second example illustrates the use of the `offset` argument that shifts all the breaks by a specified amount:

`r columns(3, 1/2)`
```{r}
axs + scale_x_continuous(breaks = scales::breaks_width(800))
axs + scale_x_continuous(breaks = scales::breaks_width(800, offset = 200))
axs + scale_x_continuous(breaks = scales::breaks_width(800, offset = -200))
```

Notice the difference between setting an offset of 200 and -200.

### Date scale breaks {#date-scales}
\index{Date/times} \index{Data!date/time} \index{Time} \index{Scales!date/time} \indexf{scale\_x\_datetime}

A special case arises when an aesthetic is mapped to a date/time type: such as the base `Date` (for dates) and `POSIXct` (for date-times) classes, as well as the `hms` class for "time of day" values provided by the hms package [@hms]. If your dates are in a different format you will need to convert them using `as.Date()`, `as.POSIXct()` or `hms::as_hms()`. You may also find the lubridate package helpful to manipulate date/time data [@lubridate]. 

Assuming you have appropriately formatted data mapped to the x aesthetic, ggplot2 will use `scale_x_date()` as the default scale for dates and `scale_x_datetime()` as the default scale for date-time data. The corresponding scales for other aesthetics follow the usual naming rules. Date scales behave similarly to other continuous scales, but contain additional arguments that are allow you to work in date-friendly units. This section discusses breaks: controlling the labels for date scales is discussed in Section \@ref(date-labels).

The `date_breaks` argument allows you to position breaks by date units (years, months, weeks, days, hours, minutes, and seconds). For example, `date_breaks = "2 weeks"` will place a major tick mark every two weeks and `date_breaks = 25 years"` will place them every 25 years:

`r columns(2, 1 / 2)`
```{r date-scale}
date_base <- ggplot(economics, aes(date, psavert)) + 
  geom_line(na.rm = TRUE) +
  labs(x = NULL, y = NULL)

date_base 
date_base + scale_x_date(date_breaks = "25 years")
```

It may be useful to note that internally `date_breaks = "25 years"` is treated as a shortcut for `breaks = scales::breaks_width("25 years")`. The longer form is typically unnecessary, but it can be useful if---as discussed in Section \@ref(break-functions)---you wish to specify an `offset`. Suppose the goal is to plot data that span the 20th century, beginning 1 January 1900, and we wish to set breaks in 25 year intervals. Specifying `date_breaks = "25 years"` produces breaks in the following fashion:

```{r}
century20 <- as.Date(c("1900-01-01", "1999-12-31"))
breaks <- scales::breaks_width("25 years")
breaks(century20)
```

Because the range in `century20` starts on 1 January and the breaks increment in whole year values, each of the generated break dates falls on 1 January. We can shift all these breaks so that they fall on 1 February by setting `offset = 31` (since there are thirty one days in January).

### Suppressing breaks

<!-- DN: I like this as a distinct section! -->

You can suppress the breaks entirely by setting them to `NULL`. For axes, this removes the tick marks, grid lines, and labels; and for legends this this removes the keys and labels.

`r columns(2, 2/3)`
```{r}
axs + scale_x_continuous(breaks = NULL)
leg + scale_fill_continuous(breaks = NULL)
```

### Minor breaks {#minor-breaks}
\index{Minor breaks}\index{Log!ticks}

You can adjust the minor breaks (the unlabelled faint grid lines that appear between the major grid lines) by supplying a numeric vector of positions to the `minor_breaks` argument. 

Minor breaks are particularly useful for log scales because they give a clear visual indicator that the scale is non-linear. To show them off, I'll first create a vector of minor break values (on the transformed scale), using `%o%` to quickly generate a multiplication table and `as.numeric()` to flatten the table to a vector.

```{r}
mb <- unique(as.numeric(1:10 %o% 10 ^ (0:3)))
mb
```

The following plots illustrate the effect of setting the minor breaks:
`r columns(2, 2/3)`
```{r}
log_base <- ggplot(toy, aes(log, const)) + geom_point()

log_base + scale_x_log10()
log_base + scale_x_log10(minor_breaks = mb)
```

As with `breaks`, you can also supply a function to `minor_breaks`, such as `scales::minor_breaks_n()` or `scales::minor_breaks_width()` functions that can be helpful in controlling the minor breaks.

For date/time scales, you can use the `date_minor_breaks` argument:

`r columns(2, 2/3)`
```{r date-scale-2}
date_base + scale_x_date(
  limits = as.Date(c("2003-01-01", "2003-04-01")),
  date_breaks = "1 month"
)

date_base + scale_x_date(
  limits = as.Date(c("2003-01-01", "2003-04-01")),
  date_breaks = "1 month",
  date_minor_breaks = "1 week"
)
```

Note that in the first plot, the minor breaks are spaced evenly between the monthly major breaks. In the second plot, the major and minor beaks follow slightly different patterns: the minor breaks are always spaced 7 days apart but the major breaks are 1 month apart. Because the months vary in length, this leads to slightly uneven spacing.



## Scale labels {#scale-labels}
\index{Axis!labels} \index{Legend!keys}

Every break is associated with a label and these can be changed by setting the `labels` argument to the scale function:

```{r}
axs + scale_x_continuous(breaks = c(2000, 4000), labels = c("2k", "4k"))
leg + scale_fill_continuous(breaks = c(2000, 4000), labels = c("2k", "4k"))
```

When the data are categorical, you also have the option of using a named vector to set the labels associated with particular values. This allows you to change some labels and not others, without altering the ordering or the breaks:

`r columns(2, 2/3)`
```{r}
base <- ggplot(toy, aes(const, txt)) + 
  geom_point() +
  labs(x = NULL, y = NULL)

base
base + scale_y_discrete(labels = c(c = "carrot", b = "banana"))
```

### Label functions {#label-functions}

In the examples above I specified the vector of `labels` manually, but ggplot2 also allows you to pass a labelling function. A function passed to `labels` should accept a numeric vector of breaks as input and return a character vector of labels (the same length as the input). The scales package provides a number of tools that will automatically construct label functions for you. Some of the more useful examples for numeric data include:

* `scales::label_bytes()` formats numbers as kilobytes, megabytes etc.
* `scales::label_comma()` formats numbers as decimals with coomas added.
* `scales::label_dollar()` formats numbers as currency.
* `scales::label_ordinal()` formats numbers in rank order: 1st, 2nd, 3rd etc.
* `scales::label_percent()` formats numbers as percentages.
* `scales::label_pvalue()` formats numbers as p-values: <.05, <.01, .34, etc.

The also contains functions relevant for other kinds of data, such as `scales::label_wrap()` which allows you to wrap long strings across lines. 

A few examples are shown below to illustrate how these functions are used:

`r columns(3)`
```{r breaks-functions}
axs + scale_y_continuous(labels = scales::label_percent())
axs + scale_y_continuous(labels = scales::label_dollar(prefix = "", suffix = "€"))
leg + scale_fill_continuous(labels = scales::label_bytes())
```

See the documentation of the scales package for more detail.

### Date scale labels {#date-labels}

Like `date_breaks`, date scales include a `date_labels` argument. It controls the display of the labels using the same formatting strings as in `strptime()` and `format()`. To display dates like 14/10/1979, for example, you would use the  string `"%d/%m/%Y"`: in this expression `%d` produces a numeric day of month, `%m` produces a numeric month, and `%Y` produces a four digit year. The table below provides a list of formatting strings:

| String        | Meaning
|:--------------|:-----------------------------------------
| `%S`          | second (00-59)
| `%M`          | minute (00-59)
| `%l`          | hour, in 12-hour clock (1-12)
| `%I`          | hour, in 12-hour clock (01-12)
| `%p`          | am/pm
| `%H`          | hour, in 24-hour clock (00-23)
| `%a`          | day of week, abbreviated (Mon-Sun)
| `%A`          | day of week, full (Monday-Sunday)
| `%e`          | day of month (1-31)
| `%d`          | day of month (01-31)
| `%m`          | month, numeric (01-12)
| `%b`          | month, abbreviated (Jan-Dec)
| `%B`          | month, full (January-December)
| `%y`          | year, without century (00-99)
| `%Y`          | year, with century (0000-9999)


One useful scenario for date label formatting is when there's insufficient room to specify a four digit year. Using `%y` ensures that only the last two digits are displayed:

`r columns(2, 1 / 2)`
```{r date-scale-3}
base <- ggplot(economics, aes(date, psavert)) + 
  geom_line(na.rm = TRUE) +
  labs(x = NULL, y = NULL)

base + scale_x_date(date_breaks = "5 years")
base + scale_x_date(date_breaks = "5 years", date_labels = "%y")
```

It can be useful to include the line break character `\n` in a formatting string, particularly when full-length month names are included:

```{r date-scale-4}
lim <- as.Date(c("2004-01-01", "2005-01-01"))

base + scale_x_date(limits = lim, date_labels = "%b %y")
base + scale_x_date(limits = lim, date_labels = "%B\n%Y")
```

In these examples I have specified the labels manually via the `date_labels` argument. An alternative approach is to pass a labelling function to the `labels` argument, in the same way I described in Section \@ref(label-functions). The scales package provides two convenient functions that will generate date labellers for you:

* `label_date()` is what `date_labels` does for you behind the scenes, so you
  rarely need to call it directly.

* `label_date_short()` automatically constructs short labels that are 
  sufficient to uniquely identify the dates: 

    ```{r date-scale-5}
    base + scale_x_date(labels = scales::label_date("%b %y"))
    base + scale_x_date(limits = lim, labels = scales::label_date_short())
    ```

### Suppressing labels

You can suppress labels with `labels = NULL`. This will remove the labels from the axis or legend while leaving its other properties unchanged:

```{r}
axs + scale_x_continuous(labels = NULL)
leg + scale_fill_continuous(labels = NULL)
```


### Exercises

1.  Recreate the following graphic:

    ```{r, echo = FALSE}
    ggplot(mpg, aes(displ, hwy)) + 
      geom_point() +  
      scale_x_continuous("Displacement", labels = scales::unit_format(suffix = "L")) + 
      scale_y_continuous(quote(paste("Highway ", (frac(miles, gallon))))) 
    ```
    
    Adjust the y axis label so that the parentheses are the right size.

1.  List the three different types of object you can supply to the
    `breaks` argument. How do `breaks` and `labels` differ?
    
1.  Recreate the following plot:

    ```{r, echo = FALSE}
    drv_labels <- c("4" = "4wd", "f" = "fwd", "r" = "rwd")
    ggplot(mpg, aes(displ, hwy)) + 
      geom_point(aes(colour = drv)) +  
      scale_colour_discrete(labels = drv_labels)
    ```

1.  What label function allows you to create mathematical expressions?
    What label function converts 1 to 1st, 2 to 2nd, and so on?
    
1.  What are the three most important arguments that apply to both 
    axes and legends? What do they do? Compare and contrast their
    operation for axes vs. legends.



## Legend merging and splitting {#legend-merge-split}

There is always a one-to-one correspondence between position scales and axes. But the connection between non-position scales and legend is more complex: one legend may need to draw symbols from multiple layers ("merging"), or one aesthetic may need multiple legends ("splitting").

### Merging legends {#sub-layers-legends}
\index{Legend}

Merging legends occurs quite frequently when using ggplot2. For example, if you've mapped colour to both points and lines, the keys will show both points and lines. If you've mapped fill colour, you get a rectangle. Note the way the legend varies in the plots below:

`r columns(3)`
```{r legend-geom, echo = FALSE}
base <- ggplot(toy, aes(const, up, colour = txt))
base + geom_point()
base + geom_point() + geom_path(aes(group = 1))
base + geom_raster(aes(fill = txt))
```

By default, a layer will only appear if the corresponding aesthetic is mapped to a variable with `aes()`. You can override whether or not a layer appears in the legend with `show.legend`: `FALSE` to prevent a layer from ever appearing in the legend; `TRUE` forces it to appear when it otherwise wouldn't. Using `TRUE` can be useful in conjunction with the following trick to make points stand out:

`r columns(2, 2/3)`
```{r}
ggplot(toy, aes(up, up)) + 
  geom_point(size = 4, colour = "grey20") +
  geom_point(aes(colour = txt), size = 2) 

ggplot(toy, aes(up, up)) + 
  geom_point(size = 4, colour = "grey20", show.legend = TRUE) +
  geom_point(aes(colour = txt), size = 2) 
```

ggplot2 tries to use the fewest number of legends to accurately convey the aesthetics used in the plot. It does this by combining legends where the same variable is mapped to different aesthetics. The figure below shows how this works for points: if both colour and shape are mapped to the same variable, then only a single legend is necessary. \index{Legend!merging}

`r columns(3)`
```{r legend-merge}
base <- ggplot(toy, aes(const, up)) +
  scale_x_continuous(NULL, breaks = NULL)
base + geom_point(aes(colour = txt))
base + geom_point(aes(shape = txt))
base + geom_point(aes(shape = txt, colour = txt))
```

In order for legends to be merged, they must have the same `name`. So if you change the name of one of the scales, you'll need to change it for all of them. One way to do this is by using `labs()` helper function:

`r columns(3, 3/2)`
```{r}
base <- ggplot(toy, aes(const, up)) + 
  geom_point(aes(shape = txt, colour = txt)) + 
  scale_x_continuous(NULL, breaks = NULL)

base
base + labs(shape = "Split legend")
base + labs(shape = "Merged legend", colour = "Merged legend")
```


### Splitting legends

Splitting a legend is a much less common data visualisation task. In general it is not advisable to map one aesthetic (e.g. colour) to multiple variables, and so by default ggplot2 does not allow you to "split" the colour aesthetic into multiple scales with separate legends. Nevertheless, there are exceptions to this general rule, and it is possible to override this behaviour using the ggnewscale package [@ggnewscale]. The `ggnewscale::new_scale_colour()` command acts as an instruction to ggplot2 to initialise a new colour scale: scale and guide commands that appear above the `new_scale_colour()` command will be applied to the first colour scale, and commands that appear below are applied to the second colour scale. 

To illustrate this the plot on the left uses `geom_point()` to display a large marker for each vehicle make in the `mpg` data, with a single colour scale that maps to the year. On the right, a second `geom_point()` layer is overlaid on the plot using small markers: this layer is associated with a different colour scale, used to indicate whether the vehicle has a 4-cylinder engine.

`r columns(2, 2/3)`
```{r}
base <- ggplot(mpg, aes(displ, hwy)) + 
  geom_point(aes(colour = factor(year)), size = 5) + 
  scale_colour_brewer("year", type = "qual", palette = 5) 

base
base + 
  ggnewscale::new_scale_colour() + 
  geom_point(aes(colour = cyl == 4), size = 1, fill = NA) + 
  scale_colour_manual("4 cylinder", values = c("grey60", "black"))
```

Additional details, including functions that apply to other scale types, are available on the package website, <https://github.com/eliocamp/ggnewscale>.

## Legend positioning {#legend-layout}

A number of settings that affect the overall display of the legends are controlled through the theme system. You'll learn more about that in Section \@ref(themes), but for now, all you need to know is that you modify theme settings with the `theme()` function. \index{Themes!legend} 

The position and justification of legends are controlled by the theme setting `legend.position`, which takes values "right", "left", "top", "bottom", or "none" (no legend). \index{Legend!layout}

`r columns(2, 2/3)`
```{r legend-position}
base <- ggplot(toy, aes(up, up)) + 
  geom_point(aes(colour = txt), size = 3) + 
  xlab(NULL) + 
  ylab(NULL)

base + theme(legend.position = "left")
base + theme(legend.position = "right") # the default 
base + theme(legend.position = "bottom")
base + theme(legend.position = "none")
```

Switching between left/right and top/bottom modifies how the keys in each legend are laid out (horizontal or vertically), and how multiple legends are stacked (horizontal or vertically). If needed, you can adjust those options independently:

* `legend.direction`: layout of items in legends ("horizontal" or "vertical").

* `legend.box`: arrangement of multiple legends ("horizontal" or "vertical").

* `legend.box.just`: justification of each legend within the overall bounding 
   box, when there are multiple legends ("top", "bottom", "left", or "right").

Alternatively, if there's a lot of blank space in your plot you might want to place the legend inside the plot. You can do this by setting `legend.position` to a numeric vector of length two. The numbers represent a relative location in the panel area: `c(0, 1)` is the top-left corner and `c(1, 0)` is the bottom-right corner. You control which corner of the legend the `legend.position` refers to with `legend.justification`, which is specified in a similar way. Unfortunately positioning the legend exactly where you want it requires a lot of trial and error.

`r columns(3, 1.5)`
```{r legend-position-man}
base <- ggplot(toy, aes(up, up)) + 
  geom_point(aes(colour = txt), size = 3)

base + theme(legend.position = c(0, 1), legend.justification = c(0, 1))
base + theme(legend.position = c(0.5, 0.5), legend.justification = c(0.5, 0.5))
base + theme(legend.position = c(1, 0), legend.justification = c(1, 0))
```

There's also a margin around the legends, which you can suppress with `legend.margin = unit(0, "mm")`.

## Legend key glyphs {#legend-glyph}

In most cases the default glyphs shown in the legend key will be appropriate to the layer and the aesthetic. Line plots of different colours will show up as lines of different colours in the legend, boxplots will appear as small boxplots in the legend, and so on. Should you need to override this behaviour, the `key_glyph` argument can be used to associate a particular layer with a different kind of glyph. For example:

`r columns(2, 1/2)`
```{r}
base <- ggplot(economics, aes(date, psavert, color = "savings"))

base + geom_line()
base + geom_line(key_glyph = "timeseries")
```

More precisely, each geom is associated with a function such as `draw_key_path()`, `draw_key_boxplot()` or `draw_key_path()` which is responsible for drawing the key when the legend is created. You can pass the desired key drawing function directly: for example, `base + geom_line(key_glyph = draw_key_timeseries)` would also produce the plot shown above right.



### Exercises

1.  How do you make legends appear to the left of the plot?

1.  What's gone wrong with this plot? How could you fix it?

    `r columns(1, 2 / 3)`
    ```{r}
    ggplot(mpg, aes(displ, hwy)) + 
      geom_point(aes(colour = drv, shape = drv)) + 
      scale_colour_discrete("Drive train")
    ```

1.  Can you recreate the code for this plot?

    `r columns(1, 2 / 3)`
    ```{r, echo = FALSE}
    ggplot(mpg, aes(displ, hwy, colour = class)) + 
      geom_point(show.legend = FALSE) + 
      geom_smooth(method = "lm", se = FALSE) + 
      theme(legend.position = "bottom") + 
      guides(colour = guide_legend(nrow = 1))
    ```






