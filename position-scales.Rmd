```{r setup position-scales-chap, include = FALSE}
source("common.R")
columns(1, 2 / 3)
toy <- data.frame(
  const = 1, 
  up = 1:4,
  txt = letters[1:4], 
  big = (1:4)*1000,
  log = c(2, 5, 10, 2000)
)
```

# Position scales {#scale-position}

Every plot has two position scales corresponding to the x and y aesthetics. Typically the user specifies the variables mapped to x and y explicitly, but sometimes an aesthetic is mapped to a computed variable, as happens with `geom_histogram()`, and does not need to be explicitly specified. For example, the following plot specifications are equivalent:

```{r, fig.show = "hide", message = FALSE}
ggplot(mpg, aes(x = displ)) + geom_histogram()
ggplot(mpg, aes(x = displ, y = after_stat(count))) + geom_histogram()
```

Although the first example does not state the y-aesthetic mapping explicitly, it still exists and is associated with (in this case) a continuous position scale.

\index{Scales!position} \index{Positioning!scales} 

Before diving into the details of how scale functions work, it is useful to note that internally all scale functions in ggplot2 belong to one of three fundamental types; continuous scales, discrete scales, and binned scales. Each fundamental type is handled by one of three scale constructor functions; `continuous_scale()`, `discrete_scale()` and `binned_scale()`. Although you should never need to call these constructor functions, they form the organising structure for later sections in this chapter.


The most common continuous position scales are the default `scale_x_continuous()` and `scale_y_continuous()` functions. In the simplest case they map linearly from the data value to a location on the plot. There are several other position scales for continuous variables---`scale_x_log10()`, `scale_x_reverse()`, etc---most of which are convenience functions used to provide easy access to common transformations:

`r columns(3)`
```{r}
base <- ggplot(mpg, aes(displ, hwy)) + geom_point()

base
base + scale_x_reverse()
base + scale_y_reverse()
```

For more information on scale transformations see Section \@ref(scale-transformation).
\indexf{scale\_x\_continuous} 

It is also possible to map discrete variables to position scales, with the default scales being `scale_x_discrete()` and `scale_y_discrete()` in this case. For example, the following two plot specifications are equivalent

```{r default-scales-discrete, fig.show = "hide"}
ggplot(mpg, aes(x = hwy, y = class)) + 
  geom_point()

ggplot(mpg, aes(x = hwy, y = class)) + 
  geom_point() + 
  scale_x_continuous() +
  scale_y_discrete()
```

Internally, ggplot2 handles discrete scales by mapping each category to an integer value and then drawing the geom at the corresponding coordinate location. To illustrate this, we can add a custom annotation (see Section \@ref(custom-annotations)) to the plot:

`r columns(1)`
```{r}
ggplot(mpg, aes(x = hwy, y = class)) + 
  geom_point() +
  annotate("text", x = 5, y = 1:7, label = 1:7)
```

A variation on discrete position scales are binned scales, where a continuous variable is sliced into multiple bins and the discretised variable is plotted. For example, if we want to modify the plot above to show the number of observations at each location, we could use `geom_count()` instead of `geom_point()` so that the size of the dots scales with the number of observations. As the left plot below illustrates, this is an improvement but is still rather cluttered. To improve this, the plot on the right uses `scale_x_binned()` to cut the `hwy` values into 10 bins before passing them to the geom:

`r columns(2, 2/3)`
```{r}
base <- ggplot(mpg, aes(hwy, class)) + geom_count()

base 
base + scale_x_binned(n.breaks = 10)
```


## Scale transformation {#scale-transformation}

<!-- DN: This section is something of a promissory note. It ought to be possible to transform binned scales (e.g., reverse binned axis, construct bins on the reciprocal value etc, but I'm having problems getting this to work nicely). For now this is written as if only continuous transformations exist -->

When working with continuous data, the default is to map linearly from the data space onto the aesthetic space. It is possible to override this default using transformations. Every continuous scale takes a `trans` argument, allowing the use of a variety of transformations:
\index{Scales!position} \index{Transformation!scales} \index{Log!scale} \indexf{scale\_x\_log10}

`r columns(2, 1)`
```{r}
# convert from fuel economy to fuel consumption
ggplot(mpg, aes(displ, hwy)) + 
  geom_point() + 
  scale_y_continuous(trans = "reciprocal")

# log transform x and y axes
ggplot(diamonds, aes(price, carat)) + 
  geom_bin2d() + 
  scale_x_continuous(trans = "log10") +
  scale_y_continuous(trans = "log10")
```

The transformation is carried out by a "transformer", which describes the transformation, its inverse, and how to draw the labels. You can construct your own transformer using `scales::trans_new()`, but --- as the plots above illustrate --- ggplot2 understands many common transformations supplied by the scales package. The following table lists the most common variants: 

| Name      | Function $f(x)$         | Inverse $f^{-1}(y)$
|-----------|-------------------------|------------------------
| asn       | $\tanh^{-1}(x)$         | $\tanh(y)$
| exp       | $e ^ x$                 | $\log(y)$
| identity  | $x$                     | $y$
| log       | $\log(x)$               | $e ^ y$
| log10     | $\log_{10}(x)$          | $10 ^ y$
| log2      | $\log_2(x)$             | $2 ^ y$
| logit     | $\log(\frac{x}{1 - x})$ | $\frac{1}{1 + e(y)}$
| pow10     | $10^x$                  | $\log_{10}(y)$
| probit    | $\Phi(x)$               | $\Phi^{-1}(y)$
| reciprocal| $x^{-1}$                | $y^{-1}$
| reverse   | $-x$                    | $-y$
| sqrt      | $x^{1/2}$               | $y ^ 2$

To simplify matters, ggplot2 provides convenience functions for the most common transformations: `scale_x_log10()`, `scale_x_sqrt()` and `scale_x_reverse()` provide the relevant transformation on the x axis, with similar functions provided for the y axis. Thus code below produces the same two plots shown in the previous example:

```{r, fig.show="hide"}
ggplot(mpg, aes(displ, hwy)) + 
  geom_point() +
  scale_y_reverse()

ggplot(diamonds, aes(price, carat)) + 
  geom_bin2d() + 
  scale_x_log10() +
  scale_y_log10()
```

Note that there is nothing preventing you from performing these transformations manually. For example, instead of using `scale_x_log10()` to transform the scale, you could transform the data instead and plot `log10(x)`. The appearance of the geom will be the same, but the tick labels will be different. Specifically, if you use a transformed scale, the axes will be labelled in the original data space; if you transform the data, the axes will be labelled in the transformed space. Regardless of which method you use, the transformation occurs before any statistical summaries. To transform _after_ statistical computation use `coord_trans()`. See Section \@ref(cartesian) for more details.


## Axis ticks/breaks {#scale-breaks}

In the same way that the `name` argument to a scale function governs axis titles and legend titles, the `breaks` argument controls which values appear as tick marks on axes and as keys on legends. 
\index{Axis!ticks} \index{Axis!breaks}

`r columns(2, 2 / 3)`
```{r breaks-labels}
axs <- ggplot(toy, aes(big, const)) + 
  geom_point() + 
  labs(x = NULL, y = NULL)

axs
axs + scale_x_continuous(breaks = c(2000, 4000))
```

### Break functions {#break-functions}

In the examples above, I specified breaks manually, but ggplot2 also allows you to pass a function to `breaks`. This function should have one argument that specifies the limits of the scale (a numeric vector of length two), and it should return a numeric vector of breaks. You can write your own break function, but in many cases there is no need, thanks to the scales package [@scales]. It provides several tools that are useful for this purpose:

* `scales::breaks_extended()`	creates automatic breaks for numeric axes.
* `scales::breaks_log()`	creates breaks appropriate for log axes.
* `scales::breaks_pretty()`	creates "pretty" breaks for date/times.
* `scales::breaks_width()`	creates equally spaced breaks.

The `breaks_extended()` function is the standard method used in ggplot2, and accordingly the first two plots below are the same. I can alter the desired number of breaks by setting `n = 2`, as illustrated in the third plot. Note that `breaks_extended()` treats `n` as a suggestion rather than a strict constraint. If you need to specify exact breaks it is better to do so manually.  

`r columns(3, 1/2)`
```{r}
axs
axs + scale_x_continuous(breaks = scales::breaks_extended())
axs + scale_x_continuous(breaks = scales::breaks_extended(n = 2))
```

Another approach that is sometimes useful is specifying a fixed `width` that defines the spacing between breaks. The `breaks_width()` function is used for this. The first example below shows how to fix the width at a specific value; the second example illustrates the use of the `offset` argument that shifts all the breaks by a specified amount:

`r columns(3, 1/2)`
```{r}
axs + scale_x_continuous(breaks = scales::breaks_width(800))
axs + scale_x_continuous(breaks = scales::breaks_width(800, offset = 200))
axs + scale_x_continuous(breaks = scales::breaks_width(800, offset = -200))
```

Notice the difference between setting an offset of 200 and -200.

### Date scale breaks {#date-scales}
\index{Date/times} \index{Data!date/time} \index{Time} \index{Scales!date/time} \indexf{scale\_x\_datetime}

A special case arises when an aesthetic is mapped to a date/time type: such as the base `Date` (for dates) and `POSIXct` (for date-times) classes, as well as the `hms` class for "time of day" values provided by the hms package [@hms]. If your dates are in a different format you will need to convert them using `as.Date()`, `as.POSIXct()` or `hms::as_hms()`. You may also find the lubridate package helpful to manipulate date/time data [@lubridate]. 

Assuming you have appropriately formatted data mapped to the x aesthetic, ggplot2 will use `scale_x_date()` as the default scale for dates and `scale_x_datetime()` as the default scale for date-time data. The corresponding scales for other aesthetics follow the usual naming rules. Date scales behave similarly to other continuous scales, but contain additional arguments that are allow you to work in date-friendly units. This section discusses breaks: controlling the labels for date scales is discussed in Section \@ref(date-labels).

The `date_breaks` argument allows you to position breaks by date units (years, months, weeks, days, hours, minutes, and seconds). For example, `date_breaks = "2 weeks"` will place a major tick mark every two weeks and `date_breaks = 25 years"` will place them every 25 years:

`r columns(2, 1 / 2)`
```{r date-scale}
date_base <- ggplot(economics, aes(date, psavert)) + 
  geom_line(na.rm = TRUE) +
  labs(x = NULL, y = NULL)

date_base 
date_base + scale_x_date(date_breaks = "25 years")
```

It may be useful to note that internally `date_breaks = "25 years"` is treated as a shortcut for `breaks = scales::breaks_width("25 years")`. The longer form is typically unnecessary, but it can be useful if---as discussed in Section \@ref(break-functions)---you wish to specify an `offset`. Suppose the goal is to plot data that span the 20th century, beginning 1 January 1900, and we wish to set breaks in 25 year intervals. Specifying `date_breaks = "25 years"` produces breaks in the following fashion:

```{r}
century20 <- as.Date(c("1900-01-01", "1999-12-31"))
breaks <- scales::breaks_width("25 years")
breaks(century20)
```

Because the range in `century20` starts on 1 January and the breaks increment in whole year values, each of the generated break dates falls on 1 January. We can shift all these breaks so that they fall on 1 February by setting `offset = 31` (since there are thirty one days in January).


### Minor breaks {#minor-breaks}
\index{Minor breaks}\index{Log!ticks}

You can adjust the minor breaks (the unlabelled faint grid lines that appear between the major grid lines) by supplying a numeric vector of positions to the `minor_breaks` argument. 

Minor breaks are particularly useful for log scales because they give a clear visual indicator that the scale is non-linear. To show them off, I'll first create a vector of minor break values (on the transformed scale), using `%o%` to quickly generate a multiplication table and `as.numeric()` to flatten the table to a vector.

```{r}
mb <- unique(as.numeric(1:10 %o% 10 ^ (0:3)))
mb
```

The following plots illustrate the effect of setting the minor breaks:
`r columns(2, 2/3)`
```{r}
log_base <- ggplot(toy, aes(log, const)) + geom_point()

log_base + scale_x_log10()
log_base + scale_x_log10(minor_breaks = mb)
```

As with `breaks`, you can also supply a function to `minor_breaks`, such as `scales::minor_breaks_n()` or `scales::minor_breaks_width()` functions that can be helpful in controlling the minor breaks.

For date/time scales, you can use the `date_minor_breaks` argument:

`r columns(2, 2/3)`
```{r date-scale-2}
date_base + scale_x_date(
  limits = as.Date(c("2003-01-01", "2003-04-01")),
  date_breaks = "1 month"
)

date_base + scale_x_date(
  limits = as.Date(c("2003-01-01", "2003-04-01")),
  date_breaks = "1 month",
  date_minor_breaks = "1 week"
)
```

Note that in the first plot, the minor breaks are spaced evenly between the monthly major breaks. In the second plot, the major and minor beaks follow slightly different patterns: the minor breaks are always spaced 7 days apart but the major breaks are 1 month apart. Because the months vary in length, this leads to slightly uneven spacing.



## Axis labels {#scale-labels}
\index{Axis!labels} \index{Legend!keys}

Every break is associated with a label and these can be changed by setting the `labels` argument to the scale function:

```{r}
axs + scale_x_continuous(breaks = c(2000, 4000), labels = c("2k", "4k"))
```

When the data are categorical, you also have the option of using a named vector to set the labels associated with particular values. This allows you to change some labels and not others, without altering the ordering or the breaks:

`r columns(2, 2/3)`
```{r}
base <- ggplot(toy, aes(const, txt)) + 
  geom_point() +
  labs(x = NULL, y = NULL)

base
base + scale_y_discrete(labels = c(c = "carrot", b = "banana"))
```

### Label functions {#label-functions}

In the examples above I specified the vector of `labels` manually, but ggplot2 also allows you to pass a labelling function. A function passed to `labels` should accept a numeric vector of breaks as input and return a character vector of labels (the same length as the input). The scales package provides a number of tools that will automatically construct label functions for you. Some of the more useful examples for numeric data include:

* `scales::label_bytes()` formats numbers as kilobytes, megabytes etc.
* `scales::label_comma()` formats numbers as decimals with coomas added.
* `scales::label_dollar()` formats numbers as currency.
* `scales::label_ordinal()` formats numbers in rank order: 1st, 2nd, 3rd etc.
* `scales::label_percent()` formats numbers as percentages.
* `scales::label_pvalue()` formats numbers as p-values: <.05, <.01, .34, etc.

The also contains functions relevant for other kinds of data, such as `scales::label_wrap()` which allows you to wrap long strings across lines. 

A few examples are shown below to illustrate how these functions are used:

`r columns(3)`
```{r breaks-functions}
axs + scale_y_continuous(labels = scales::label_percent())
axs + scale_y_continuous(labels = scales::label_dollar(prefix = "", suffix = "€"))
```

See the documentation of the scales package for more detail.

### Date scale labels {#date-labels}

Like `date_breaks`, date scales include a `date_labels` argument. It controls the display of the labels using the same formatting strings as in `strptime()` and `format()`. To display dates like 14/10/1979, for example, you would use the  string `"%d/%m/%Y"`: in this expression `%d` produces a numeric day of month, `%m` produces a numeric month, and `%Y` produces a four digit year. The table below provides a list of formatting strings:

| String        | Meaning
|:--------------|:-----------------------------------------
| `%S`          | second (00-59)
| `%M`          | minute (00-59)
| `%l`          | hour, in 12-hour clock (1-12)
| `%I`          | hour, in 12-hour clock (01-12)
| `%p`          | am/pm
| `%H`          | hour, in 24-hour clock (00-23)
| `%a`          | day of week, abbreviated (Mon-Sun)
| `%A`          | day of week, full (Monday-Sunday)
| `%e`          | day of month (1-31)
| `%d`          | day of month (01-31)
| `%m`          | month, numeric (01-12)
| `%b`          | month, abbreviated (Jan-Dec)
| `%B`          | month, full (January-December)
| `%y`          | year, without century (00-99)
| `%Y`          | year, with century (0000-9999)


One useful scenario for date label formatting is when there's insufficient room to specify a four digit year. Using `%y` ensures that only the last two digits are displayed:

`r columns(2, 1 / 2)`
```{r date-scale-3}
base <- ggplot(economics, aes(date, psavert)) + 
  geom_line(na.rm = TRUE) +
  labs(x = NULL, y = NULL)

base + scale_x_date(date_breaks = "5 years")
base + scale_x_date(date_breaks = "5 years", date_labels = "%y")
```

It can be useful to include the line break character `\n` in a formatting string, particularly when full-length month names are included:

```{r date-scale-4}
lim <- as.Date(c("2004-01-01", "2005-01-01"))

base + scale_x_date(limits = lim, date_labels = "%b %y")
base + scale_x_date(limits = lim, date_labels = "%B\n%Y")
```

In these examples I have specified the labels manually via the `date_labels` argument. An alternative approach is to pass a labelling function to the `labels` argument, in the same way I described in Section \@ref(label-functions). The scales package provides two convenient functions that will generate date labellers for you:

* `label_date()` is what `date_labels` does for you behind the scenes, so you
  rarely need to call it directly.

* `label_date_short()` automatically constructs short labels that are 
  sufficient to uniquely identify the dates: 

    ```{r date-scale-5}
    base + scale_x_date(labels = scales::label_date("%b %y"))
    base + scale_x_date(limits = lim, labels = scales::label_date_short())
    ```


### Label positioning

Another way to modify the behaviour of axes and legends is with the `guide` argument of the relevant scale function or---perhaps more conveniently---the `guides()` helper function. The `guides()` helper works in a similar way to the `labs()` helper function described in Section \@ref(scale-name). Guide functions exist mostly to control plot legends, but---as legends and axes are both kinds of guide---ggplot2 also supplies a `guide_axis()` function for axes. Its main purpose is to provide additional controls that prevent labels from overlapping:

`r columns(2, 2/3)`
```{r}
base <- ggplot(mpg, aes(manufacturer, hwy)) + geom_boxplot() 

base + guides(x = guide_axis(n.dodge = 3))
base + guides(x = guide_axis(angle = 90))
```




### Exercises

1.  Recreate the following graphic:

    ```{r, echo = FALSE}
    ggplot(mpg, aes(displ, hwy)) + 
      geom_point() +  
      scale_x_continuous("Displacement", labels = scales::unit_format(suffix = "L")) + 
      scale_y_continuous(quote(paste("Highway ", (frac(miles, gallon))))) 
    ```
    
    Adjust the y axis label so that the parentheses are the right size.

1.  List the three different types of object you can supply to the
    `breaks` argument. How do `breaks` and `labels` differ?
    
1.  Recreate the following plot:

    ```{r, echo = FALSE}
    drv_labels <- c("4" = "4wd", "f" = "fwd", "r" = "rwd")
    ggplot(mpg, aes(displ, hwy)) + 
      geom_point(aes(colour = drv)) +  
      scale_colour_discrete(labels = drv_labels)
    ```

1.  What label function allows you to create mathematical expressions?
    What label function converts 1 to 1st, 2 to 2nd, and so on?
    
1.  What are the three most important arguments that apply to both 
    axes and legends? What do they do? Compare and contrast their
    operation for axes vs. legends.


## Removing axes

You can suppress the breaks entirely by setting them to `NULL`. For axes, this removes the tick marks, grid lines, and labels; and for legends this this removes the keys and labels. Alternatively you can suppress only the labels with `labels = NULL`. This will remove the labels from the axis or legend while leaving its other properties unchanged. Finally, you can remove the axis, which suppresses breaks and labels but leaves grid lines.

`r columns(3, 2/3)`
```{r}
axs + scale_x_continuous(breaks = NULL)
axs + scale_x_continuous(labels = NULL)
axs + guides(x = guide_none())
```


## Axis expansion

If you have eagle eyes, you'll have noticed that the visual range of the axes actually extends a little bit past the numeric limits that I have specified in the various examples. This ensures that the data does not overlap the axes, which is usually (but not always) desirable. 

You can eliminate this this space with `expand = c(0, 0)`. One scenario where it is usually preferable to remove this space is when using `geom_raster()`: \index{Axis!expansion}

<!-- mention expansion() since it documents the parameters? -->

`r columns(2, 1, 1)`
```{r}
ggplot(faithfuld, aes(waiting, eruptions)) + 
  geom_raster(aes(fill = density)) + 
  theme(legend.position = "none")

ggplot(faithfuld, aes(waiting, eruptions)) + 
  geom_raster(aes(fill = density)) + 
  scale_x_continuous(expand = c(0,0)) + 
  scale_y_continuous(expand = c(0,0)) +
  theme(legend.position = "none")
```

### Exercises

1.  The following code creates two plots of the mpg dataset. Modify the code
    so that the legend and axes match, without using facetting!
    
    `r columns(2, 2/3)`
    ```{r}
    fwd <- subset(mpg, drv == "f")
    rwd <- subset(mpg, drv == "r")
    
    ggplot(fwd, aes(displ, hwy, colour = class)) + geom_point()
    ggplot(rwd, aes(displ, hwy, colour = class)) + geom_point()
    ```

1.  What does `expand_limits()` do and how does it work?  Read the source code.

1.  What happens if you add two `xlim()` calls to the same plot? Why?

1.  What does `scale_x_continuous(limits = c(NA, NA))` do?







<!-- DN: This was the beginning of the binned transformation section:

### Binned scales

`r columns(2)`
```{r}
base <- ggplot(mpg, aes(hwy)) + geom_bar()

p1 <- base + scale_x_binned(breaks = seq(-50,50,10), limits = c(-50, 50))
p2 <- base + scale_x_binned(breaks = seq(-50,50,10), limits = c(-50, 50), trans = "reverse")
```





Binned scales can be transformed, much like continuous scales, but some care is required because the bins are constructed in the transformed space. In some cases this can produce undesirable outcomes. In the code below, I take a uniformly distributed variable and use `scale_x_binned()` and `geom_bar()` to construct a histogram of the logarithmically transformed data. 

`r columns(1, 1/2, 1)`
```{r}
df <- data.frame(val = runif(10000, 1, 20000))
ggplot(df, aes(log10(val))) + geom_bar() + scale_x_binned()
```

In this example the transformation takes place in the data: the x aesthetic is mapped to the value of `log10(val)`, and no scale transformation is applied. The bins are evenly spaced on this logarithmic scale. Alternatively, you can specify the transformation by setting `trans = "log10"` in the scale function:

`r columns(1, 1/2, 1)`
```{r}
ggplot(df, aes(val)) + geom_bar() + scale_x_binned(trans="log10") 
```

The unevenly spaced bins occur due to an interaction of two things: (1) binned scales use breaks to construct the bins, and (2) the default breaks for a transformed scale are specified by the transformation and are designed to look nice, but may not be good for binning data. The solution to this is to override the default breaks: 

`r columns(1, 1/2, 1)`
```{r}
ggplot(df, aes(val)) + geom_bar() + 
  scale_x_binned(trans="log10", breaks = 3^(0:9))  
```

-->





